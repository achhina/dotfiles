#!/usr/bin/env -S uv run --script
# /// script
# dependencies = ["bashlex", "click", "rich"]
# ///

import sys
import json
from pathlib import Path
import click
from rich.console import Console
import bashlex

console = Console()
err_console = Console(stderr=True)


def extract_command_from_line(line, shell_type):
    """Extract command from history line, handling shell-specific formats."""
    if shell_type == 'zsh':
        # Strip zsh timestamp metadata: ': 1234567890:0;command'
        if line.startswith(':'):
            line = line.split(';', 1)[1] if ';' in line else line
    return line.strip()


def extract_commands(node, commands_dict):
    """Recursively walk AST to find commands and subcommands."""
    if node.kind == 'command':
        parts = [n.word for n in node.parts if hasattr(n, 'word')]
        if parts:
            base_cmd = parts[0]

            # Add base command
            if base_cmd not in commands_dict:
                commands_dict[base_cmd] = set()

            # Look for subcommand (first arg that doesn't start with -)
            if len(parts) > 1:
                for arg in parts[1:]:
                    if not arg.startswith('-'):
                        commands_dict[base_cmd].add(f"{base_cmd} {arg}")
                        break  # Only first subcommand

    # Recurse into child nodes (handles pipes, &&, ||, etc.)
    if hasattr(node, 'parts'):
        for part in node.parts:
            extract_commands(part, commands_dict)

    # Handle list nodes (compound commands)
    if hasattr(node, 'list'):
        for item in node.list:
            extract_commands(item, commands_dict)


def process_history_file(file_path, shell_type, commands_dict):
    """Process a single history file with error handling."""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            for line_num, line in enumerate(f, 1):
                if not line.strip():
                    continue

                try:
                    cmd = extract_command_from_line(line, shell_type)
                    if cmd:
                        nodes = bashlex.parse(cmd)
                        for node in nodes:
                            extract_commands(node, commands_dict)
                except (bashlex.errors.ParsingError, NotImplementedError):
                    # Skip unparseable lines and unsupported bash features silently
                    pass
                except Exception as e:
                    # Log unexpected errors to stderr
                    err_console.print(
                        f"[dim red]Warning: {file_path}:{line_num}: {e}[/dim red]"
                    )
    except FileNotFoundError:
        err_console.print(
            f"[red]Error: History file not found: {file_path}[/red]"
        )
        sys.exit(1)


def print_categorized(commands_dict, use_json):
    """Print results in categorized format or JSON."""
    if use_json:
        output = {cmd: sorted(list(subs)) for cmd, subs in commands_dict.items()}
        print(json.dumps(output, indent=2))
        return

    for base_cmd in sorted(commands_dict.keys()):
        console.print(f"\n[bold cyan]{base_cmd}[/bold cyan]")

        subcommands = sorted(commands_dict[base_cmd])
        for subcmd in subcommands:
            console.print(f"  {subcmd}")


@click.command()
@click.option('--json', is_flag=True, help='Output as JSON')
def main(json):
    """Extract commands and subcommands from shell history."""
    commands_dict = {}

    # Auto-detect history files
    history_files = []
    if (zsh_hist := Path.home() / '.zsh_history').exists():
        history_files.append(('zsh', zsh_hist))
    if (bash_hist := Path.home() / '.bash_history').exists():
        history_files.append(('bash', bash_hist))

    if not history_files:
        err_console.print("[red]No history files found[/red]")
        sys.exit(1)

    for shell_type, file_path in history_files:
        process_history_file(file_path, shell_type, commands_dict)

    print_categorized(commands_dict, json)


if __name__ == '__main__':
    main()
