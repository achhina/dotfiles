#!/usr/bin/env bash
set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Global variables
PREVIEW_MODE=false
CLEANUP_MODE=false
CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"

# Parse command line arguments
for arg in "$@"; do
  case $arg in
    --preview|-p)
      PREVIEW_MODE=true
      shift
      ;;
    --cleanup|-c)
      CLEANUP_MODE=true
      shift
      ;;
    --help|-h)
      echo "Usage: $0 [options]"
      echo "Options:"
      echo "  --preview, -p    Show what would be updated without applying changes"
      echo "  --cleanup, -c    Also expire old generations and run garbage collection"
      echo "  --help, -h       Show this help message"
      exit 0
      ;;
    *)
      # Unknown option
      ;;
  esac
done

run_cmd() {
  echo -e "${BLUE}→${NC} $*"
  "$@"
}

log_info() {
  echo -e "${BLUE}ℹ${NC} $1"
}

log_success() {
  echo -e "${GREEN}✅${NC} $1"
}

log_warning() {
  echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
  echo -e "${RED}❌${NC} $1"
}

cleanup_on_error() {
  log_error "Update failed! Cleaning up..."
  log_info "If you need to rollback, use: home-manager generations"
  exit 1
}

# Set up error handling
trap cleanup_on_error ERR

check_git_repo() {
  if ! git -C "$CONFIG_HOME" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    log_error "Config directory is not a git repository"
    exit 1
  fi
}

commit_flake_lock() {
  # Check if flake.lock actually changed
  if git -C "$CONFIG_HOME" diff-index --quiet HEAD -- nix/flake.lock 2>/dev/null; then
    log_info "No changes to flake.lock - skipping commit"
    return 0
  fi

  log_info "Generating update summary..."

  # Get detailed information about updated packages
  local update_summary
  update_summary=$(generate_update_summary)

  log_info "Committing flake.lock updates..."
  git -C "$CONFIG_HOME" add nix/flake.lock

  git -C "$CONFIG_HOME" commit -m "Update flake inputs

$update_summary

Generated by update script on $(date '+%Y-%m-%d %H:%M:%S')" >/dev/null

  log_success "Flake lock committed successfully"
}

generate_update_summary() {
  # Get package version changes using nix profile diff-closures
  log_info "Analyzing package version changes..."

  local version_changes
  version_changes=$(get_package_version_changes)

  if [ -n "$version_changes" ]; then
    echo "Package version changes:"
    echo "$version_changes"
  else
    echo "- No package version changes detected"
  fi

  # Also include flake input summary
  local input_summary
  input_summary=$(get_flake_input_summary)

  if [ -n "$input_summary" ]; then
    echo ""
    echo "$input_summary"
  fi
}

get_package_version_changes() {
  # Get the two most recent home-manager generations and compare them
  local generations
  generations=$(home-manager generations 2>/dev/null | head -2)

  if [ -z "$generations" ]; then
    return
  fi

  # Extract store paths for current and previous generations
  local current_path
  local previous_path
  current_path=$(echo "$generations" | sed -n '1p' | sed 's|.* -> \(/nix/store/[^ ]*\).*|\1|')
  previous_path=$(echo "$generations" | sed -n '2p' | sed 's|.* -> \(/nix/store/[^ ]*\).*|\1|')

  # If we don't have both paths, we can't compare
  if [ -z "$current_path" ] || [ -z "$previous_path" ]; then
    return
  fi

  # Use nix store diff-closures to compare the two generations
  nix store diff-closures "$previous_path" "$current_path" 2>/dev/null
}

get_flake_input_summary() {
  local lock_diff
  lock_diff=$(git -C "$CONFIG_HOME" diff HEAD~1 nix/flake.lock 2>/dev/null || echo "")

  if [ -z "$lock_diff" ]; then
    return
  fi

  # Count updated inputs
  local updated_count
  updated_count=$(echo "$lock_diff" | grep -c '"lastModified"' 2>/dev/null || echo "0")

  # Extract input names that changed
  local changed_inputs
  changed_inputs=$(echo "$lock_diff" | grep -B5 '"lastModified"' | grep -E '"[a-zA-Z0-9_-]+": \{' | sed 's/.*"\([^"]*\)": {.*/\1/' | sort -u)

  echo "Updated $updated_count flake inputs:"
  if [ -n "$changed_inputs" ]; then
    printf '%s\n' "$changed_inputs" | sed 's/^/- /'
  fi
}

preview_updates() {
  log_info "Previewing available updates..."

  # Show what would be updated in flake inputs
  echo -e "${CYAN}📋 Checking for flake input updates:${NC}"
  nix flake update --dry-run "$CONFIG_HOME/nix" 2>/dev/null || {
    log_info "Running flake update check..."
    # Create a temporary copy to check what would change
    temp_dir=$(mktemp -d)
    cp -r "$CONFIG_HOME/nix" "$temp_dir/"
    nix flake update --flake "$temp_dir/nix" 2>/dev/null || true

    if ! diff -q "$CONFIG_HOME/nix/flake.lock" "$temp_dir/nix/flake.lock" >/dev/null 2>&1; then
      echo -e "${YELLOW}📦 Updates available for flake inputs${NC}"

      # Show detailed diff
      local input_changes
      input_changes=$(get_flake_input_preview "$temp_dir/nix/flake.lock")
      if [ -n "$input_changes" ]; then
        echo "$input_changes"
      fi
    else
      echo -e "${GREEN}✅ All flake inputs are up to date${NC}"
    fi

    rm -rf "$temp_dir"
  }

  echo -e "${CYAN}📋 Current system status:${NC}"
  echo "  • Current generation: $(home-manager generations | head -1 | awk '{print $1}' | sed 's/id-//')"
  echo "  • Configuration path: $CONFIG_HOME/nix"

  log_info "Preview completed. Use 'update' without --preview to apply changes."
}

get_flake_input_preview() {
  local new_lock_file="$1"
  local old_lock_file="$CONFIG_HOME/nix/flake.lock"

  if [ ! -f "$new_lock_file" ] || [ ! -f "$old_lock_file" ]; then
    return
  fi

  # Extract updated input names and their new versions
  local changes
  changes=$(diff -u "$old_lock_file" "$new_lock_file" 2>/dev/null | grep -E '^\+.*"lastModified"' | head -5)

  if [ -n "$changes" ]; then
    echo "  📦 Inputs that would be updated:"
    # This is a simplified preview - in practice, parsing JSON diffs is complex
    echo "    • Multiple inputs would be updated"
    echo "    • Run without --preview to see detailed changes"
  fi
}

main() {
  if [ "$PREVIEW_MODE" = true ]; then
    echo -e "${CYAN}👀 Preview mode - showing what would be updated${NC}"
    preview_updates
    exit 0
  fi

  echo -e "${GREEN}🔄 Starting system update...${NC}"

  # Ensure we're in a git repository
  check_git_repo

  # Update flake inputs
  log_info "Updating flake inputs..."
  run_cmd nix flake update --flake "$CONFIG_HOME/nix"

  # Commit flake.lock changes if any
  if ! git -C "$CONFIG_HOME" diff-index --quiet HEAD -- nix/flake.lock 2>/dev/null; then
    commit_flake_lock
  else
    log_info "No flake.lock changes - inputs are already up to date"
  fi

  # Always apply home-manager configuration to ensure system is up to date
  log_info "Applying home-manager configuration..."

  # Detect system for flake configuration (mirrors hm alias logic)
  local arch="$HOSTTYPE"  # bash built-in: arm64, x86_64, etc.
  local system_type
  case "$arch" in
    arm64|aarch64)
      system_type="aarch64-darwin"
      ;;
    x86_64)
      system_type="x86_64-darwin"
      ;;
    *)
      log_error "Unsupported system architecture: $arch"
      exit 1
      ;;
  esac

  run_cmd home-manager switch --flake "$CONFIG_HOME/nix#$system_type"

  # Show package changes between previous and current generation
  log_info "Package changes in this update:"
  local package_diff
  package_diff=$(get_package_version_changes)
  if [ -n "$package_diff" ]; then
    echo "$package_diff"
  else
    echo "  No package version changes detected"
  fi

  # Commit tridactyl config updates if they changed (Home Manager generates the symlink)
  if ! git -C "$CONFIG_HOME" diff-index --quiet HEAD -- tridactyl/tridactylrc 2>/dev/null; then
    log_info "Committing tridactyl configuration updates..."
    git -C "$CONFIG_HOME" add tridactyl/tridactylrc
    git -C "$CONFIG_HOME" commit -m "Update tridactyl configuration

Generated by Home Manager update on $(date '+%Y-%m-%d %H:%M:%S')" >/dev/null
    log_success "Tridactyl configuration committed successfully"
  else
    log_info "No tridactyl configuration changes to commit"
  fi

  # Source tmux configuration if tmux is running
  if command -v tmux >/dev/null 2>&1 && tmux list-sessions >/dev/null 2>&1; then
    log_info "Sourcing tmux configuration..."
    if [ -f "$CONFIG_HOME/tmux/tmux.conf" ]; then
      run_cmd tmux source-file "$CONFIG_HOME/tmux/tmux.conf"
      log_success "Tmux configuration sourced successfully"
    else
      log_warning "Tmux configuration file not found at $CONFIG_HOME/tmux/tmux.conf"
    fi
  else
    log_info "Tmux is not running or not available - skipping tmux config sourcing"
  fi

  # Run cleanup if requested
  if [ "$CLEANUP_MODE" = true ]; then
    log_info "Running cleanup: expiring old generations and collecting garbage..."

    # Expire old home-manager generations (older than 1 minute)
    log_info "Expiring old home-manager generations..."
    run_cmd home-manager expire-generations '-1 minute'

    # Run Nix garbage collection
    log_info "Running Nix garbage collection..."
    run_cmd nix-collect-garbage

    log_success "Cleanup completed successfully!"
  fi

  log_success "System update completed successfully!"
}

# Run main function
main "$@"
